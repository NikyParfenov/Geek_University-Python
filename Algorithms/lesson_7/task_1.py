# 1. Отсортируйте по убыванию методом пузырька одномерный целочисленный массив, заданный случайными числами
# на промежутке [-100; 100). Выведите на экран исходный и отсортированный массивы.
# Примечания:
# a. алгоритм сортировки должен быть в виде функции, которая принимает на вход массив данных,
# b. постарайтесь сделать алгоритм умнее, но помните, что у вас должна остаться сортировка пузырьком.
# Улучшенные версии сортировки, например, расчёской, шейкерная и другие в зачёт не идут.
from random import randint


def bubble_sort(array: list) -> None:
    """
    Функция сортировки пузырьком.
    :param array: list
    :return: None
    """
    n = 1
    counter = 0
    while n < len(array):
        for i in range(len(array) - n):
            if array[i] < array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]
            counter += 1
        n += 1
    print(f'Число перестановок по 1-му варианту: {counter}')


def bubble_sort_modified(array: list) -> None:
    """
    Модифицированная функция сортировки пузырьком, которая проверяет были ли вообще перестановки на текущем шаге,
    иначе flag останавливает цикл while, чтобы не прогонять цикл до конца массива
    :param array: list
    :return: None
    """
    n = len(array) - 1
    counter = 0
    flag = True
    while flag:
        flag = False
        for i in range(0, n):
            if array[i] < array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]
                flag = True
            counter += 1
        n -= 1
    print(f'Число перестановок по 2-му варианту: {counter}')


# Копируем массив "а" в "b" для сравнения производительности.
a = [randint(-100, 100) for _ in range(30)]
b = a[:]

# В целом 2-й вариант быстрее на несколько перестановок, но иногда сопадает с 1-м
print(f'Исходный массив:\n{a}')
bubble_sort(a)
bubble_sort_modified(b)
print(f'Отсортированный массив (по 1-му варианту):\n{a}')
print(f'Отсортированный массив (по 2-му варианту):\n{b}')
